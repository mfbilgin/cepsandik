events {
    worker_connections 1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    # Lua package path
    lua_package_path "/usr/local/openresty/nginx/lua/?.lua;;";

    # Rate limiting shared memory (10MB)
    lua_shared_dict rate_limit 10m;

    # Log format
    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /usr/local/openresty/nginx/logs/access.log  main;

    # Upstream services
    upstream user_service {
        server user-service:8080;
    }

    upstream community_service {
        server community-service:8083;
    }

    server {
        listen 80;
        server_name localhost;

        # Allow larger file uploads (10MB for profile images)
        client_max_body_size 10M;

        # ========================================
        # PUBLIC ENDPOINTS - NO AUTH REQUIRED
        # ========================================
        
        # Auth endpoints (login, register, etc.)
        location /api/v1/auth {
            # Rate limit only: 10 req/min (brute-force protection)
            access_by_lua_block {
                local rate_limit = require "rate_limit"
                rate_limit.check("auth")
            }
            
            proxy_pass http://user_service;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # Email change confirmation (public - accessed via email link)
        location ^~ /api/v1/users/confirm-email-change {
            # No auth required - just rate limit
            access_by_lua_block {
                local rate_limit = require "rate_limit"
                rate_limit.check("auth")
            }
            
            proxy_pass http://user_service;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # ========================================
        # PROTECTED ENDPOINTS - JWT REQUIRED
        # ========================================

        # User Service - Protected
        location /api/v1/users {
            # Rate limit + JWT auth combined
            access_by_lua_block {
                local rate_limit = require "rate_limit"
                rate_limit.check("protected")
                
                -- JWT auth inline (from jwt_auth.lua)
                local jwt = require "resty.jwt"
                local cjson = require "cjson"
                
                local JWT_SECRET = os.getenv("JWT_SECRET") or "94010e81e0b61f9869c0232025086fbc83a2d60975231b86fa714a8a29b2a76d"
                local INTERNAL_SECRET = os.getenv("INTERNAL_JWT_SECRET") or "95d597309c7a8d06c95bab3136b53274e61dbbfcb1d1ca0fb9a24dff342d63ed"
                
                local auth_header = ngx.var.http_authorization
                if not auth_header then
                    ngx.status = 401
                    ngx.header["Content-Type"] = "application/json"
                    ngx.say(cjson.encode({success = false, message = "Bu işlem için giriş yapmanız gerekmektedir."}))
                    return ngx.exit(401)
                end
                
                local token = auth_header:match("^Bearer%s+(.+)$")
                if not token then
                    ngx.status = 401
                    ngx.header["Content-Type"] = "application/json"
                    ngx.say(cjson.encode({success = false, message = "Geçersiz kimlik bilgisi formatı."}))
                    return ngx.exit(401)
                end
                
                local jwt_obj = jwt:verify(JWT_SECRET, token)
                if not jwt_obj.verified then
                    ngx.status = 401
                    ngx.header["Content-Type"] = "application/json"
                    -- Check if expired
                    if jwt_obj.reason and string.find(jwt_obj.reason, "exp") then
                        ngx.say(cjson.encode({success = false, message = "Oturumunuz sonlandı, lütfen tekrar giriş yapın."}))
                    else
                        ngx.say(cjson.encode({success = false, message = "Oturum doğrulanamadı, lütfen tekrar giriş yapın."}))
                    end
                    return ngx.exit(401)
                end
                
                -- Double check expiration (belt and suspenders)
                local now = ngx.time()
                if jwt_obj.payload.exp and jwt_obj.payload.exp < now then
                    ngx.status = 401
                    ngx.header["Content-Type"] = "application/json"
                    ngx.say(cjson.encode({success = false, message = "Oturumunuz sonlandı, lütfen tekrar giriş yapın."}))
                    return ngx.exit(401)
                end
                
                local user_id = jwt_obj.payload.sub or jwt_obj.payload.userId or jwt_obj.payload.id
                local roles = jwt_obj.payload.roles or {"USER"}
                local platform_role = jwt_obj.payload.platformRole or "USER"
                
                if not user_id then
                    ngx.status = 401
                    ngx.header["Content-Type"] = "application/json"
                    ngx.say(cjson.encode({success = false, message = "Oturum bilgisi eksik, lütfen tekrar giriş yapın."}))
                    return ngx.exit(401)
                end
                
                -- Generate internal token
                local internal_jwt = jwt:sign(INTERNAL_SECRET, {
                    header = {typ = "JWT", alg = "HS256"},
                    payload = {
                        uid = user_id,
                        roles = roles,
                        scope = {"community:read", "community:write"},
                        iss = "api-gateway",
                        iat = now,
                        exp = now + 30
                    }
                })
                
                ngx.req.set_header("X-Internal-Auth", internal_jwt)
                ngx.req.set_header("X-User-Id", tostring(user_id))
                ngx.req.set_header("X-Platform-Role", platform_role)
            }
            
            proxy_pass http://user_service;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # Admin Service - Protected (ADMIN role required)
        location /api/v1/admin {
            # Rate limit + JWT auth combined
            access_by_lua_block {
                local rate_limit = require "rate_limit"
                rate_limit.check("protected")
                
                -- JWT auth inline
                local jwt = require "resty.jwt"
                local cjson = require "cjson"
                
                local JWT_SECRET = os.getenv("JWT_SECRET") or "94010e81e0b61f9869c0232025086fbc83a2d60975231b86fa714a8a29b2a76d"
                local INTERNAL_SECRET = os.getenv("INTERNAL_JWT_SECRET") or "95d597309c7a8d06c95bab3136b53274e61dbbfcb1d1ca0fb9a24dff342d63ed"
                
                local auth_header = ngx.var.http_authorization
                if not auth_header then
                    ngx.status = 401
                    ngx.header["Content-Type"] = "application/json"
                    ngx.say(cjson.encode({success = false, message = "Yetkisiz erişim. Erişim reddedildi."}))
                    return ngx.exit(401)
                end
                
                local token = auth_header:match("^Bearer%s+(.+)$")
                if not token then
                    ngx.status = 401
                    ngx.header["Content-Type"] = "application/json"
                    ngx.say(cjson.encode({success = false, message = "Yetkisiz erişim. Erişim reddedildi."}))
                    return ngx.exit(401)
                end
                
                local jwt_obj = jwt:verify(JWT_SECRET, token)
                if not jwt_obj.verified then
                    ngx.status = 401
                    ngx.header["Content-Type"] = "application/json"
                    ngx.say(cjson.encode({success = false, message = "Yetkisiz erişim. Erişim reddedildi."}))
                    return ngx.exit(401)
                end
                
                local now = ngx.time()
                if jwt_obj.payload.exp and jwt_obj.payload.exp < now then
                    ngx.status = 401
                    ngx.header["Content-Type"] = "application/json"
                    ngx.say(cjson.encode({success = false, message = "Oturum süresi doldu. Lütfen tekrar giriş yapın."}))
                    return ngx.exit(401)
                end
                
                local user_id = jwt_obj.payload.sub or jwt_obj.payload.userId or jwt_obj.payload.id
                local roles = jwt_obj.payload.roles or {"USER"}
                local platform_role = jwt_obj.payload.platformRole or "USER"
                
                if not user_id then
                    ngx.status = 401
                    ngx.header["Content-Type"] = "application/json"
                    ngx.say(cjson.encode({success = false, message = "Yetkisiz erişim. Erişim reddedildi."}))
                    return ngx.exit(401)
                end
                
                -- Generate internal token
                local internal_jwt = jwt:sign(INTERNAL_SECRET, {
                    header = {typ = "JWT", alg = "HS256"},
                    payload = {
                        uid = user_id,
                        roles = roles,
                        scope = {"admin:read", "admin:write"},
                        iss = "api-gateway",
                        iat = now,
                        exp = now + 30
                    }
                })
                
                ngx.req.set_header("X-Internal-Auth", internal_jwt)
                ngx.req.set_header("X-User-Id", tostring(user_id))
                ngx.req.set_header("X-Platform-Role", platform_role)
            }
            
            proxy_pass http://user_service;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # Community Service - Protected
        location /api/v1/communities {
            # Rate limit + JWT auth combined
            access_by_lua_block {
                local rate_limit = require "rate_limit"
                rate_limit.check("protected")
                
                -- JWT auth inline
                local jwt = require "resty.jwt"
                local cjson = require "cjson"
                
                local JWT_SECRET = os.getenv("JWT_SECRET") or "94010e81e0b61f9869c0232025086fbc83a2d60975231b86fa714a8a29b2a76d"
                local INTERNAL_SECRET = os.getenv("INTERNAL_JWT_SECRET") or "95d597309c7a8d06c95bab3136b53274e61dbbfcb1d1ca0fb9a24dff342d63ed"
                
                local auth_header = ngx.var.http_authorization
                if not auth_header then
                    ngx.status = 401
                    ngx.header["Content-Type"] = "application/json"
                    ngx.say(cjson.encode({success = false, message = "Yetkisiz erişim. Erişim reddedildi."}))
                    return ngx.exit(401)
                end
                
                local token = auth_header:match("^Bearer%s+(.+)$")
                if not token then
                    ngx.status = 401
                    ngx.header["Content-Type"] = "application/json"
                    ngx.say(cjson.encode({success = false, message = "Yetkisiz erişim. Erişim reddedildi."}))
                    return ngx.exit(401)
                end
                
                local jwt_obj = jwt:verify(JWT_SECRET, token)
                if not jwt_obj.verified then
                    ngx.status = 401
                    ngx.header["Content-Type"] = "application/json"
                    ngx.say(cjson.encode({success = false, message = "Yetkisiz erişim. Erişim reddedildi."}))
                    return ngx.exit(401)
                end
                
                local now = ngx.time()
                if jwt_obj.payload.exp and jwt_obj.payload.exp < now then
                    ngx.status = 401
                    ngx.header["Content-Type"] = "application/json"
                    ngx.say(cjson.encode({success = false, message = "Oturum süresi dolu. Lütfen tekrar giriş yapın."}))
                    return ngx.exit(401)
                end
                
                local user_id = jwt_obj.payload.sub or jwt_obj.payload.userId or jwt_obj.payload.id
                local roles = jwt_obj.payload.roles or {"USER"}
                local platform_role = jwt_obj.payload.platformRole or "USER"
                
                if not user_id then
                    ngx.status = 401
                    ngx.header["Content-Type"] = "application/json"
                    ngx.say(cjson.encode({success = false, message = "Yetkisiz erişim. Erişim reddedildi."}))
                    return ngx.exit(401)
                end
                
                -- Generate internal token
                local internal_jwt = jwt:sign(INTERNAL_SECRET, {
                    header = {typ = "JWT", alg = "HS256"},
                    payload = {
                        uid = user_id,
                        roles = roles,
                        scope = {"community:read", "community:write"},
                        iss = "api-gateway",
                        iat = now,
                        exp = now + 30
                    }
                })
                
                ngx.req.set_header("X-Internal-Auth", internal_jwt)
                ngx.req.set_header("X-User-Id", tostring(user_id))
                ngx.req.set_header("X-Platform-Role", platform_role)
            }
            
            proxy_pass http://community_service;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # Actuator endpoints (Health checks - public, no rate limit)
        location /user/actuator {
            rewrite ^/user/actuator/(.*)$ /actuator/$1 break;
            rewrite ^/user/actuator$ /actuator break;
            proxy_pass http://user_service;
        }

        # Community Service Health Check
        location /community/actuator {
            rewrite ^/community/actuator/(.*)$ /actuator/$1 break;
            rewrite ^/community/actuator$ /actuator break;
            proxy_pass http://community_service;
        }

        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   /usr/share/nginx/html;
        }
    }
}
